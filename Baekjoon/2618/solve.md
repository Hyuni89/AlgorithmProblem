# 2618. Police Car  
DP문제는 항상 새롭고 어렵다는 생각이 든다. 이 문제 역시 DP로 풀어야 할 것 같다는 생각은 했지만 내가 생각해 낸 방법으론 풀리지 않았다. 문제를 다방면으로 살펴보고, 공통된 부분을 묶어내고, 반복적인 부분을 찾아내고, 어디서부터 접근할지 항상 깊게 생각해 보고 연구해 봐야겠다.  

## Brief  
격자 모양의 마을 교차로에서 사고가 일어나면 각기 다른 위치에 있던 경찰차 두대가 가까운 사고 현장으로 출동을 한다. 이 때, 경찰차의 이동거리가 최소가 되게 하는 방법은?  

> Input  
> N (5 <= N <= 1,000)  
> W (1 <= W <= 1,000)  
> A<sub>1x</sub> A<sub>1y</sub> (1 <= A <= N)  
> ...  
> A<sub>Wx</sub> A<sub>Wy</sub>  

## Approach  
1. 문제를 처음 보고 느낀건 '절대 Greedy하게 풀 수 없을 것 같다'이다. 결론은 DP 뿐인데...  
2. 처음 생각해 낸 방법은 한 사건을 해결하기 위해 두 경찰차를 모두 출동시켜 보고 가장 최적의 값을 기록하는 식으로 했지만 이 방법 역시 기록이 포함된 Greedy 기법과 동일하다고 느꼈다. 모든 경우의 수는 트리의 형태로 2<sup>W</sup>개가 있는데 상위 노드에서 최적의 값이 나오지 않았다고 가지를 쳐버리면 절대 답이 나올수 없게 되기 때문이다.  

## Solution  
1. DP이다. 무엇을 기록해 볼지 생각해 보자. W번째 사건을 해결할 때 최소 이동거리가 될 수도 있고, W-1번째 사건에서 W번째 사건 사이의 최소 이동거리가 될 수도 있다. 여러 정보를 기록할 수 있는데, W번째 사건을 해결할 때 최소 이동거리가 가장 적합할 것 같다.  
2. 경찰차는 사건을 해결하고 그 자리에 머문다. 따라서 경찰차의 좌표를 딱히 기록할 필요 없이 마지막에 처리한 사건 번호만 가지고 있으면 된다. 경찰차는 두 대이므로 각각의 히스토리를 기록하려면 2중 배열이 필요할 것이다.  
3. Top-Down, Bottom-Up을 구별해서 잘 사용해야 한다. 예를 들어, 5개의 사건 sequence에서 1-2-1-1-2의 경우와 2-1-1-1-2의 경우를 비교한다고 가정해 보자. 앞의 두개의 사건에 배차된 경찰차가 다르고 뒤의 세개의 사건에 배차된 경찰차는 같다. Bottom-Up의 경우 sequence에 따라 앞에서부터 기록을 해 나가면 매 sequence마다 값이 새롭게 갱신되어 중복되는 값이 존재하지 않는다. 하지만 Top-Down의 경우 뒤에서부터 경로가 저장되므로 마지막 1-1-2의 배차가 동일하게 기록되는 것을 알 수 있다.  

## Link  
[2618. Police Car](https://www.acmicpc.net/problem/2618)  
